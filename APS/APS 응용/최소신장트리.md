## ğŸ“Œìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬

#### ğŸ’¡ ê·¸ë˜í”„ì—ì„œì˜ ìµœì†Œ ë¹„ìš© ë¬¸ì œ

 1. ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” íŠ¸ë¦¬ `(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)`
 2. ë‘ ì •ì  ì‚¬ì´ì˜ ìµœì†Œ ë¹„ìš©ì˜ ê²½ë¡œ ì°¾ê¸° `(ìµœë‹¨ ê²½ë¡œ)`
   
#### ì‹ ì¥ íŠ¸ë¦¬
   - nê°œì˜ ì •ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬´í–¥ ê·¸ë˜í”„ì—ì„œ `nê°œì˜ ì •ì `ê³¼ `n-1ê°œì˜ ê°„ì„ `ìœ¼ë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬
   - ì–´ë–¤ ì •ì ë„ ì™¸í†¨ì´ê°€ ë˜ì§€ ì•Šë„ë¡ ì—°ê²°ëœ íŠ¸ë¦¬. BUT ì‚¬ì´í´ì´ ìƒê¸°ë©´ ì•ˆëœë‹¤!
#### ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (Minimum Spanning Tree)
   - ë¬´í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” **ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œ**ì¸ ì‹ ì¥ íŠ¸ë¦¬

## ğŸ“ŒKRUSKAL ì•Œê³ ë¦¬ì¦˜
- **ê°„ì„ **ì„ í•˜ë‚˜ì”© ì„ íƒí•´ì„œ MSTë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜
- ê°„ì„ ì„ ì´ìš©í•˜ê¸° ë•Œë¬¸ì— `ë¦¬ìŠ¤íŠ¸`ë¥¼ í™œìš©í•œë‹¤.
### ğŸ’¡ ì•Œê³ ë¦¬ì¦˜

>1. ìµœì´ˆ, ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
>2. **ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ë‚®ì€ ê°„ì„ **ë¶€í„° ì„ íƒí•˜ë©´ì„œ íŠ¸ë¦¬ë¥¼ ì¦ê°€ì‹œí‚´.
>â—ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë©´ ë‹¤ìŒìœ¼ë¡œ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ê°„ì„  ì„ íƒ
>3. N-1ê°œì˜ ê°„ì„ ì´ ì„ íƒ ë  ë•Œê¹Œì§€ 2ë¥¼ ë°˜ë³µ.

<img src="https://images.velog.io/images/velogmj/post/b6c5ba6e-166a-49fd-8264-2985b34686a6/image.png" width="70%">



### ğŸ’¡ ì•Œê³ ë¦¬ì¦˜ ì ìš© ì˜ˆ

<img src="https://images.velog.io/images/velogmj/post/1cc8442a-3638-4522-af06-6dfb744d5595/image.png" width="70%">

### ğŸ’¡ ì½”ë“œ

```java
public class Kruskal {

	static class Edge implements Comparable<Edge> {

		int start, end, weight;

		public Edge(int start, int end, int weight) {
			super();
			this.start = start;
			this.end = end;
			this.weight = weight;

		}

		@Override
		public int compareTo(Edge o) { // compareTo ë‚˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ oë¥¼ ë¹„êµ
			//return this.weight-o.weight; //ê°„ì„ ì˜ ë¶€í˜¸ê°€ ëª¨ë‘ ê°™ì„ ë•Œ
			return Integer.compare(this.weight, o.weight);
		}

	}

	static int[] parents; // ë¶€ëª¨ì›ì†Œë¥¼ ê´€ë¦¬(íŠ¸ë¦¬ì²˜ëŸ¼ ì‚¬ìš©)

	private static void make() {
		parents = new int[V];
		// ëª¨ë“  ì›ì†Œë¥¼ ìì‹ ì„ ëŒ€í‘œìë¡œ ë§Œë“¦
		for (int i = 0; i < V; i++) {
			parents[i] = i;
		}
	}

	// aê°€ ì†í•œ ì§‘í•©ì˜ ëŒ€í‘œì ì°¾ê¸°
	private static int find(int a) {
		if (a == parents[a]) return a; // ìì‹ ì´ ëŒ€í‘œì.
		return parents[a] = find(parents[a]); // ìì‹ ì´ ì†í•© ì§‘í•©ì˜ ëŒ€í‘œìë¥¼ ìì‹ ì˜ ë¶€ëª¨ë¡œ : path compression
	}

	// ë‘ ì›ì†Œë¥¼ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ê¸°(ëŒ€í‘œìë¥¼ ì´ìš©í•´ì„œ í•©ì¹¨)
	private static boolean union(int a, int b) {
		int aRoot = find(a);
		int bRoot = find(b);
		if (aRoot == bRoot) return false; // ì´ë¯¸ ê°™ì€ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ì§€ ì•ŠìŒ

		parents[bRoot] = aRoot;
		return true;
	}

	static int V, E;
	static Edge[] edgeList;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		V = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());

		// ê°„ì„ ë¦¬ìŠ¤íŠ¸ ì‘ì„±
		edgeList = new Edge[E];

		for (int i = 0; i < E; i++) {
			st = new StringTokenizer(br.readLine());
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			int weight = Integer.parseInt(st.nextToken());
			edgeList[i] = new Edge(start, end, weight);

		}
		Arrays.sort(edgeList); // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

		make(); // ëª¨ë“  ì •ì ì„ ê°ê°ì˜ ì§‘í•©ìœ¼ë¡œ ë§Œë“¤ê³  ì¶œë°œ

		// ê°„ì„  í•˜ë‚˜ì”© ì‹œë„í•˜ë©° íŠ¸ë¦¬ ë§Œë“¤ì–´ ê°.
		int cnt = 0, result = 0;
		for (Edge edge : edgeList) {
			if (union(edge.start, edge.end)) {
				// ê°„ì„ ì„ ì´ì–´ë´!!
				result += edge.weight;
				if (++cnt == V - 1) break; // ê°„ì„ ì´ v-1ê°œê°€ ë˜ë©´ ì‹ ì¥ íŠ¸ë¦¬ ì™„ì„±
			}
		}

		System.out.println(result);
	}

}
```

## ğŸ“ŒPRIM ì•Œê³ ë¦¬ì¦˜
- í•˜ë‚˜ì˜ **ì •ì **ì—ì„œ ì—°ê²°ëœ ê°„ì„ ë“¤ ì¤‘ì— í•˜ë‚˜ì”© ì„ íƒí•˜ë©´ì„œ MSTë¥¼ ë§Œë“¤ì–´ê°€ëŠ” ë°©ì‹
- ì •ì  ì¤‘ì‹¬ì´ê¸° ë•Œë¬¸ì— `ì¸ì ‘í–‰ë ¬, ì¸ì ‘ ë¦¬ìŠ¤íŠ¸`ë¥¼ í™œìš©í•œë‹¤.

### ğŸ’¡ ì•Œê³ ë¦¬ì¦˜

> 1. **ì„ì˜ ì •ì **ì„ í•˜ë‚˜ ì„ íƒí•´ì„œ ì‹œì‘
> 2. ì„ íƒí•œ ì •ì ê³¼ ì¸ì ‘í•˜ëŠ” ì •ì ë“¤ ì¤‘ì˜ ìµœì†Œ ë¹„ìš©ì˜ ê°„ì„ ì´ ì¡´ì¬í•˜ëŠ” ì •ì  ì„ íƒ
> 3. ëª¨ë“  ì •ì ì´ ì„ íƒë  ë•Œê¹Œì§€ 1,2 ê³¼ì •ì„ ë°˜ë³µ

<img src="https://images.velog.io/images/velogmj/post/0842d1fc-b6cc-48e4-8a1c-1fe0f0dbecd1/image.png" width="75%">

- ê°„ì„ ì´ ë§ìœ¼ë©´ kruskalë³´ë‹¤ primì´ ë” íš¨ìœ¨ì ì´ë‹¤.
- kruskalì€ ê°„ì„ ì„ ì •ë ¬í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— primë³´ë‹¤ ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆë‹¤.

### ğŸ’¡ ì•Œê³ ë¦¬ì¦˜ ì ìš© ì˜ˆ

<img src="https://images.velog.io/images/velogmj/post/19fd0523-b3ad-49c3-9818-bcce70249659/image.png" width="75%">

<img src="https://images.velog.io/images/velogmj/post/f27ef36d-5321-469f-b821-3c434ef7cbb2/image.png" width="75%">

### ğŸ’¡ ì½”ë“œ
```java
public class PrimTest {

	public static void main(String[] args) throws Exception {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());

		int[][] adjMatrix = new int[N][N]; //ì¸ì ‘í–‰ë ¬
		boolean[] v = new boolean[N];
		int[] minEdge = new int[N];

		for (int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				adjMatrix[i][j] = Integer.parseInt(st.nextToken());
			}
			minEdge[i] = Integer.MAX_VALUE;
		}

		int result = 0;
		minEdge[0] = 0; // ì„ì˜ì˜ ì‹œì‘ì  0ì˜ ê°„ì„ ë¹„ìš©ì„ 0ìœ¼ë¡œ ì„¸íŒ…

		// 
		for (int i = 0; i < N; i++) {
			// 1. ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ë˜ì§€ì•Šì€ ì •ì  ì¤‘ ìµœì†Œê°„ì„ ë¹„ìš©ì˜ ì •ì  ì°¾ê¸°
			int min = Integer.MAX_VALUE;
			int minVertex = -1; // ìµœì†Œ ê°„ì„ ë¹„ìš©ì˜ ì •ì ë²ˆí˜¸

			
			for (int j = 0; j < N; j++) {
				if (!v[j] && min > minEdge[j]) {
					min = minEdge[j];
					minVertex = j;
				}
			}

			v[minVertex] = true; // ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ ì‹œí‚´
			result += min; // ê°„ì„ ë¹„ìš© ëˆ„ì 

			// 2. ì„ íƒëœ ì •ì  ê¸°ì¤€ìœ¼ë¡œ ì‹ ì¥íŠ¸ë¦¬ì— ì—°ê²°ë˜ì§€ ì•Šì€ íƒ€ ì •ì ê³¼ì˜ ê°„ì„  ë¹„ìš© ìµœì†Œë¡œ ì—…ë°ì´íŠ¸

			for (int j = 0; j < N; j++) {
				if (!v[j] && adjMatrix[minVertex][j] != 0 && minEdge[j] > adjMatrix[minVertex][j]) 
					minEdge[j] = adjMatrix[minVertex][j];
			}

		}

		System.out.println(result);
	}

}

```

